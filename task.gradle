// 深入了解Tasks

/*
* 1. 定义Task(三种方式)
* 普通：
*   task(hello)
* String：
*   task('hello')
* Create:
*   tasks.create(name: 'hello')
*
* */
//task(hello) << {
//task('hello') << {
tasks.create(name: 'hello'){
    println "hello"
}

/*
* 解读：
*  task 的名字是 “myCopy”, 但是它是 “Copy” 类(type).
*  可以有许多同样 type 但是不同名字的 tasks
* */
//task(copy, type:Copy){
//task('copy', type:Copy){
tasks.create(name: 'copy', type: Copy){
//    println "srcDir" + "$srcDir"
    println "buildDir" + "$buildDir"
    from(file('srcDir'))
    into(buildDir)
}

/*
* 2. 定位 tasks
* */
// 通过属性获取 tasks
println "hello.name:" + hello.name
println "project.hello.name:" + project.hello.name

// 通过 tasks collection 获取 tasks
println "容器1：" + tasks.hello.name
println "容器2：" + tasks['hello'].name

/*
*
* 例子 15.6. 通过路径获取 tasks
*
* TODO: 无法验证
*
*build.gradle:
project(':projectA') {
    task hello
}

task hello

println tasks.getByPath('projectA:hello').path
println tasks.getByPath(':projectA:hello').path
* */

println "getByPath: " + tasks.getByPath('hello').path
println "getByPath: " + tasks.getByPath(':hello').path
//println "getByPath: " + tasks.getByPath('projectA:hello').path
//println "getByPath: " + tasks.getByPath(':projectA:hello').path

/*
* 3. 配置 tasks
* */
// 不推荐如下方式配置"myCopy"，会重复调用上下文"myCopy"
//Copy myCopy  = task(myCopy, type: Copy)
//myCopy.from 'antLoadfileReseources'
//myCopy.into 'target'
//myCopy.include('**/*.txt','**/*.properties')

// 通过"闭包 closure" 来配置一个任务
task copyTxt(type: Copy)

copyTxt {
    /*
    * TODO:
    * 执行任意命令会打印该语句（表示运行在"配置阶段"），但是不执行实际copy操作？
    * 实际copy操作在指定task时，才会执行？
    * 如：
    *   gradle -q -b task.gradle copyProp
    * */
    println "into Closure task copyTxt..."
    from 'antLoadfileResources'
    into 'target'
    include('*.txt')
//    include('*.txt', '*.properties')
}

// 在定义的时候使用闭包
task copyProp(type: Copy) {
    println "into Closure task copyProp..."
    from 'antLoadfileResources'
    into 'target'
    include('*.properties')
//    include('*.txt', '*.properties')
}
// "一个任务有配置和动作. 当使用 << 时, 你只是简单的使用捷径定义了动作. 定义在配置区域的代码只会在构建的配置阶段执行, 而且不论执行哪个任务"

/*
* 4. 给 task 加入依赖
* */
/*
TODO： 未验证，跨项目的任务依赖
project('projectA') {
    task taskX(dependsOn: ':projectB:taskY') << {
        println 'taskX'
    }
}

project('projectB') {
    task taskY << {
        println 'taskY'
    }
}
*/
/*
* 通过闭包加入依赖:
* gradle -q -b task.gradle taskX
*  lib1.
   lib2.
   taskX
* */
project
task taskX << {
    // 给任务加入描述
    description 'This task taskX`s description.' // xxx = yyy 也可以

    println 'taskX. description:' + description
}

taskX.dependsOn {
    // 更加先进的用法, 你可以通过闭包定义一个任务依赖. 闭包只能返回一个单独的 Task
    // 或者 Task 对象的 collection, 这些返回的任务就将被当做依赖
    tasks.findAll {
        task -> task.name.startsWith("lib")
    }
}

task lib1 << {
    println "lib1."
}

task lib2 << {
    println "lib2."
}

task notAlib << {
    println "notAlib."
}

/*
* 5. 给 tasks 排序
* */
// B must run after A: B必须在A后执行
lib2.mustRunAfter lib1

// B should run after A: B应当在A后执行（不然"must"严格，在某些情况下可以忽略）
taskX.shouldRunAfter notAlib

/*
* 几个注意点：
* 1. 排序规则只有在两个任务同时执行时才会被应用：
*   gradle -q -b task.gradle lib2 lib1
* 2. lib1、lib2仍能单独运行，不影响
* 3. 加上"--continue"，lib1失败后，lib2仍能运行
* */

// "shouldRunAfter"规则在一个执行循环中将被忽略
task taskY << {
    println "taskY."
}

task taskZ << {
    println "taskZ."
}

taskX.dependsOn taskY
taskY.dependsOn taskZ
/*
* 注意：下列语句失效！
* gradle -q -b task.gradle taskX
* 仍旧输出：
*   taskZ.
    taskY.
    taskX.
* */
taskZ.shouldRunAfter taskX

/*
* 6. 替换 tasks
*
* gradle -q -b task.gradle shouldBeOveride
* */
task shouldBeOveride << {
    println "orginal task."
}

// 定义为false，或者不定义overwrite，会报错："Cannot add task ':shouldBeOveride' as a task with that name already exists."
task shouldBeOveride(overwrite: true) << {
    println "new task."
}

/*
* 7. 跳过 tasks
* */
/*
*
* 使用判断条件跳过一个任务：
* 使用 onlyIf() 方法来为一个任务加入判断条件（类似Java里的If）
*
* > gradle hello -PskipHello
*  则taskZ不被执行
* */
taskZ.onlyIf {
    !project.hasProperty('skipTaskZ')
}// 注意此时闭包的作用：像变量一样传递任务，来实现判断条件。若任务应当被执行，则返回真；反之亦然。

/*
* 通过 StopExecutionException 跳过任务：
* 十分有用：在直接使用Gradle提供的任务时，它允许你为"内建的任务"加入条件来控制执行.
*
* gradle -q -b task.gradle myTask：
*   I am not affected
    before throw Exception.
* */
taskZ.doFirst{
    if (true){
        println "before throw Exception."
        // 这个动作之后的执行以及所有紧跟它的动作都会被跳过. 构建将会继续执行下一个任务.
        throw new StopExecutionException()
        println "after throw Exception."
    }
}

task myTask(dependsOn: 'taskZ'){
    println 'I am not affected'
}

// 激活和注销 tasks
task disableMe << {
    println 'This should not be printed if the task is disabled.'
}

// 激活标记。默认为真；若激活为假，则任何动作都不被执行
disableMe.enabled = false

/*
* 8. 跳过 up-to-date 的任务
*  代表这个任务已经运行过了或者说是最新的状态, 不再需要产生一次相同的输出
*
* 第一次：
*  > gradle transform
:transform
 Transforming source file.
*
* 第二次：
* > gradle transform
:transform UP-TO-DATE
* */
// TODO: 未验证
task transform {
    ext.srcFile = file('mountains.xml')
    ext.destDir = new File(buildDir, 'generated')
    // 为了使用 Gradle 的 up-to-date 检测, 你需要定义任务的输入.
    inputs.file srcFile
    // 为了使用 Gradle 的 up-to-date 检测, 你需要定义任务的输出.
    outputs.dir destDir
    doLast {
        println "Transforming source file."
        destDir.mkdirs()
        def mountains = new XmlParser().parse(srcFile)
        mountains.mountain.each { mountain ->
            def name = mountain.name[0].text()
            def height = mountain.height[0].text()
            def destFile = new File(destDir, "${name}.txt")
            destFile.text = "$name -> ${height}\n"
        }
    }
}

/*
* 9. Task 规则
* */
// 任务规则。比如，打印"ping"开头的任务
tasks.addRule("Pattern: ping<ID>"){ String taskName ->
    if (taskName.startsWith("ping")){
        task(taskName) << {
            println "Pinging: " + (taskName - 'ping')
        }
    }
}

/*
* 基于规则的任务依赖：
*
* 不能找到"pingServer1"、"pingServer2"的任务，但是这个脚本仍然会执行这些任务！
*
* gradle  -q -b task.gradle groupPing
*   Pinging: Server1
    Pinging: Server2
* */
task groupPing {
    dependsOn pingServer1, pingServer2
}

/*
* 10. 终止 tasks
*
* 注意点：
* 1. 如果要终止的任务并没有被执行 (比如上一节讲的 up-to-date) 那么终止任务并不会执行.
*   即：M 没有被执行，那么N也不会执行
* 2. 当构建创建了一个资源, 无论构建失败或成功时这个资源必须被清除的时候, 终止任务就非常有用.
* */
task taskM << {
    println "taskM."
    throw new StopExecutionException() // TODO:RuntimeException会失败。但教程并不会
    println "taskM end."
}

task taskN << {
    println "taskN."
}

// 表示"即使任务M失败了，终止任务N也会执行"
taskM.finalizedBy taskN // 这里的，"终止任务"的终止是形容词，不是动词！
